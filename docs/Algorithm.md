# Algorithm

## Find

有序列表使用二分查找

查找前 k 的元素可以使用**快速选择**或**最小堆**算法

## Tree

- 二叉树
- 平衡二叉树
- 红黑树
- 字典树

### RedBlack-Tree

红黑树是一种含有红黑节点并能自平衡的二叉查找树。它必须满足下面性质：

1. 每个节点要么是黑色，要么是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。
4. 每个红色节点的子节点一定都是黑色。
5. 任意一节点到每个叶子节点的路径都包含数量相同的黑色节点。

红黑树通过旋转和变色操作维持自平衡

- 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
- 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
- 变色：结点的颜色由红变黑或由黑变红。

插入时，新插入的节点为红色。红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。

### B+Tree

## Sort

![排序算法分类](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)

![排序算法复杂度](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

### 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

JDK 中 Arrays.sort 方法使用快速排序算法实现的，当元素少于47个时使用基于二分的插入排序。

### 并归排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

### 直接插入排序

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

### 希尔插入排序

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

### 二分插入排序

在直接插入排序的基础上，通过二分查找定位元素待插入的位置。通过减少检索提升效率。

### 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

对于有序队列，在进行第一次遍历后可以快速返回，达到 O(N) 效率。

### 选择排序

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

### 最小堆排序

取 M 个元素放入最小堆中，遍历数列剩余元素，与堆中最大的元素比较并替换。复杂度 O(N*Log(M))

### 计数排序

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

### 基数排序

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。

基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。

## Partition

### 一致性 Hash 算法

一致性哈希算法将整个哈希值组织成一个虚拟的圆环，通过节点的 hash 值确定其在哈希环上的位置，将数据的 Key 使用相同的函数计算出哈希值，并确定此数据在换上的位置，沿着顺时针行走，遇到的第一个节点就将其定为在该节点上。  
另外，节点过少时，容易因为节点分布不均匀而造成数据倾斜的问题。通过虚拟节点的机制来解决该问题。

## Other

### LRU 最近最少使用

记录每个数据的最后一次访问时间，拥有最少空闲时间的数据可以被认为将来最有可能被访问到。数据访问模式非常接近幂律分布时，LRU 近似算法会处理的很好。  
最初，Redis 只是随机的选 3个 key，然后从中淘汰，后来算法改进到 N（maxmemory-samples）个 key 的策略，默认 5个。Redis 3.0 之后又改善了算法的性能，会提供一个待淘汰候选 key 的 pool，里面默认有 16个 key，按照空闲时间排好序。更新时从 Redis 键空间随机选取 N个 key，分别计算它们的空闲时间 idle，key 只会在 pool 不满或者空闲时间大于 pool 里最小的时，才会进入 pool。从 pool 中选择空闲时间最大的 key 淘汰掉。

### LFU 最不经常使用

LFU 算法可以为每一个 key 维护一个计数器。每次 key 被访问的时候，计数器增大，然后随着时间推移，降低计数器。计数器越大，可以约等于访问越频繁。

### 布隆过滤器

运用一系列随机映射函数计算出位置，然后填充二进制向量。判断数据是否不存在。

### 布谷鸟过滤器

在布隆过滤器的基础上增加计数，可以移除无效的数据。

## TODO

- 动态规划
- 单调栈
- 前缀和
- 快慢指针
- 分治法
- 回溯
- 深度优先算法
- 非递归式深度优先算法
- 广度优先算法
- 固定窗口
- 滑动窗口（双指针）
- 连通查找
- LRU
- LRF
