# Cache

## 缓存

缓存是提升系统的查询性能最直接有效的方式，把多次参数不变的调用返回的相同结果缓存到内存中，以达到减少重复的计算或io读取操作。

通过给缓存设定一个过期时间或定时更新，可以保障最终一致性。

并发装载缓存是冗余的操作，可以通过互斥量或信号量进行限制。

### 缓存策略

- Cache-Aside：最常用的缓存策略，应用程序会在命中数据源之前先检查缓存，适合“读多”的应用场景。
  - 令缓存失效而非更新缓存，可以避免并发场景下，多个请求对缓存更新导致脏写的问题。
  - 有时候可以尝试延迟失效的方式，通过给缓存设定过期时间而非直接删除。
- Read-Through：与 Cache-Aside 策略相似，但应用程序无需管理数据源和缓存，缓存同步的操作委托给 Cache Provider，所有的数据交互都是通过缓存抽象层完成的。
- Write-Through：在数据更新时，同时写入缓存和数据源。
- Write-Back：在数据更新时只写入缓存，在数据被替换出缓存时，被修改的缓存数据会写入数据源中。或异步地定时批量更新数据源。
  - 数据持久化操作是异步的，优点是内存操作速度快，多次操作可以合并。缺点是数据可能会丢失。

### 一致性

更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。
如何解决并发场景下的双写一致性问题。

1. 先更新数据
2. 删除缓存（事务范围内）
3. 双删缓存，加入异步队列重试保障删除操作成功。
4. 缓存增加过期时间（最终一致性）

缓存本身就是通过牺牲强一致性来提高性能，因此使用缓存提升性能，就会有数据更新的延迟性。

### 缓存故障

**缓存雪崩**：缓存中的大量数据到达过期时间，导致大量的请求落到数据库。

- 随机设置 key 的过期时间，避免同一时间过期
- 热点 key 设置永不过期或定期延长
- 后台线程定时更新缓存

**缓存击穿**：热点 key 失效，导致大量并发请求到数据库，负载压力骤增。

- 热点 key 永不过期
- 后台线程定时更新缓存
- 利用 DCL 双重检查锁保证同一时刻只有一个请求可以查询数据库

**缓存穿透**：指大量请求或恶意攻击访问不存在的数据时，绕过 redis 访问数据库造成负载。

- 用较短的时间缓存不存在的数据
- 接口访问过滤，如参数的合法性校验、用户鉴权、访问频率限制
- 布隆过滤器，判断 key 是否存在数据库中。虽然会产生误判，但可以屏蔽绝大部分请求
- 布谷鸟过滤器，解决布隆过滤器只能添加无法移除的问题

**缓存预热**：系统上线或 Redis 故障重启后，缓存内还没有数据，如果并发量很大则都落到数据库中。

- 根据统计预估热点数据，通过批任务进行预热
- Sentinel 预热限流

## Redis

Redis 是一个开源的使用 ANSI C 语言编写、可基于内存亦可持久化的 Key-Value 数据库，并提供多种语言的 API的非关系型数据库。

Redis 是基于内存的数据库，最有可能的瓶颈来自于内存的大小或网络 IO 方面，因此采用单线程模型，减少多线程带来的额外消耗。redis 利用队列技术将并发访问变成串行访问。

单机吞吐量约 130k QPS/s，受 CPU 主频，内存，网络影响。

### 类型和编码

Redis 使用对象来表示数据库中的键和值，键对象都是字符串对象，而值对象主要有 String, List, Set, Sorted Set, Hash 五种常用数据类型，每种类型有多种编码格式。

```c
typedef struct redisObiect{
  unsigned type:4;
  unsigned encoding:4;
  void *ptr;
}
```

#### String

最常用的类型，可用于缓存存储序列化的对象、图片，存储会话信息，实现计数器（自增自减操作），ID 分配器，接口限速器，互斥锁，bitmap（位操作）

底层编码格式有：

- Int
  存储 64 位的 Long 类型
- Embstr
 不超于 44 字节时嵌入存储到 redisObj 中
- Raw
  采用 sds 编码保存

#### List

List 类型在 redis 3.2 版本之前使用 ziplist 或 linkedlist 格式编码，3.2 之后使用 quicklist 编码。
quicklist 是一个双端双向的链表，链表的每个节点都是一个 ziplist。这样即避免了链表额外的指针开销，又能存储大量的元素。

可实现队列，栈结构

```c
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all ziplists */
    unsigned long len;          /* number of quicklistNodes */
} quicklist;

typedef struct quicklistNode {
    struct quicklistNode *prev; //上一个node节点
    struct quicklistNode *next; //下一个node
    unsigned char *zl;            //保存的数据 压缩前ziplist 压缩后压缩的数据
    unsigned int sz;             /* ziplist size in bytes */
    unsigned int count : 16;     /* count of items in ziplist */
} quicklistNode;
```

#### Set

适用于标签去重，粉丝的共同好友。元素可以去重，求交集、并集、差集等运算。

编码格式

- IntSet
  元素均为数字且不超过 512 个时使用，有序，不可重复且适配元素大小用 int16, int32, int64 保存以节约内存
- HashTable

#### Sorted Set

编码格式

- ziplist
  当元素小于64 byte 或元素数量小于 512 时，把元素和元素字节长度紧凑的编码到字节数组中存储。元素长度少于 254 个时使用 1 byte 存储元素长度，否则使用 5 byte 存储，因此可能会导致连锁更新的问题。
- skiplist
  跳跃表是支持更快查询的有序链表，每个元素维护 backward 指针和包含多层的 forward 指针。
  每当元素被添加时生成一个 0～1 的随机数，若随机数小于 0.25 时依次想上晋升一层，最大 32层。因此实现 O(logN) 平均复杂度的快速链表。

为什么没有用红黑树替代跳表
在Redis中会有大量的范围查询的功能需求，红黑树在范围查找这方面的效率不如跳跃表，所以在范围查询方面使用跳跃表更优
红黑树的数据结构更为复杂，红黑树的插入和删除操作可能会引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速
一般来说，红黑树每个节点包含2个指针，而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。

#### Hash

适用于存储结构化数据，避免对象的某个属性更新频繁，或实现一组计数器（自增操作）

##### Hash 冲突

开放寻址法相对于链表法，冲突的代价更高，负载因子接近 1 时会发生大量的冲突，所以负载因子的上限不能太大。
链表法不需要提前分配内存，能更好的利用内存，负载因子的容忍度也很高。

##### 渐进式 rehash

redis 中存储了大量的键值对，hashtable 扩容时并非一次完成的。
在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，除了执行原本的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成之后，rehashidx 自增。

编码格式

- ziplist
- hashtable
  与 Java 中的 HashMap 实现相似，同样是通过 hash mod sizemask 定位 hash 槽，链表法（头插法）解决 hash 冲突。
  不同的是扩容机制，当 redis 未执行 bgsave 时，负载因子达到 1 时进行扩容，小于 0.1 时自动缩容。否则负载因子达到 5 时强制扩容。

```c
typedef struct dict {
         //哈希表
         dictht ht[2];
         //rehash 索引 当rehash不在进行时 值为-1
         int trehashidx; 
} dict;

typedef struct dictht {
         dictEntry **table;
         unsigned long size;
         unsigned long sizemask;
         unsigned long used;
} dictht;

typedef struct dictEntry {
         void *key;
         void *val;
         struct dictEntry *next;
} dictEntry;
```

### 淘汰策略

在每执行一个命令前，会调用 freeMemoryIfNeeded() 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis 要临时删除一些数据为当前指令清理存储空间，清理数据的策略成为逐出算法。

- allkeys-lru：优先删除最近最少使用的 key
- volatile-lru：优先删除最近最少使用并设置了 expire 的 key
- allkeys-lfu：在所有主键空间中，将访问频率最少的键值对淘汰
- volatile-lfu：在设置了过期时间的键空间中，将访问频率最少的键值对淘汰
- allkeys-random：随机删除一部分 key
- volatile-random：随机删除一部分设置了 expire 的 key
- volatile-ttl：优先删除剩余时间短的 key
- noeviction（默认）：不删除策略，达到最大内存限制是，直接返回错误信息

### 删除策略

- 定时删除：在设置键的过期时间同时，创建一个定时任务，每隔一段时间（默认 10s）就会自动运行一次。当键达到过期时间时，立即执行对键的删除操作；定时删除策略可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存。缺点是对 CPU 时间不友好，当过期键比较多时，删除任务会占用很大一部分 CPU 时间，影响服务器的响应时间和吞吐量。
- 定期删除：默认每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。通过限制删除操作执行时长和频率来减少删除操作对 CPU 的影响。并且有效的减少了因过期键带来的内存浪费。  
- 惰性删除：每次执行操作访问键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键；CPU 开销低，内存开销大。

默认使用定期删除+惰性删除的策略。

### IO 多路复用模型

多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

Redis 采用 Reactor 设计模式：事件驱动循环流程，内部实现采用 epoll + 文件事件处理器方式。epoll中的读、写、关闭、连接都转化成了事件，通过队列传递到文件事件分派器进行分派，最终交给具体的事件处理器来处理。

![Redis 文件事件分派器](https://img-blog.csdnimg.cn/20190603165626604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ndWlzdS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

### 持久化

#### RDB

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。
具体是通过 fork 命令创建子进程，把进程内存中的数据转储到文件中。主进程与子进程利用内存映射技术共享相同的内存页，当主进程的数据修改时通过 copy-on-write 技术，复制当前页并进行修改。

优点：RDB 文件紧凑、体积小，网络传输快，适合全量复制；恢复速度比 AOF 快很多，对性能影响较小  
缺点：无法做到实时持久化，文件格式兼容性差

#### AOF

优点：支持秒级持久化、兼容性好
缺点：文件大、恢复速度慢

##### AOF 持久化策略

- fsync
- everysec
- no

##### AOF 重写

AOF 采用文件追加的方式，文件会越来越大，为了避免出现此种情况，新增了重写机制。

当执行 bgrewriteaof命令，或文件的大小超过设定的阈值（auto-aof-rewrite-percentage=100%, auto-aof-rewrite-min-size=64M），redis 就会启动 aof 文件内容压缩，只保留可以恢复数据的最小指令集。

redis 会记录上次重写的 AOF 大小，默认配置时当 aof 文件大小是上次 rewrite 后大小的一倍（100%）且文件大于 64M。

rewrite 的原理：aof 文件持续增长过大时，会 fork 出子进程进行文件重写（先写临时文件，然后在 rename）。遍历新进程的内存中的数据，而非读取旧的 aof 文件，将整个内存中的数据用命令的方式重写一个新的 aof 文件，和快照方式类似。

### 通讯协议

RESP 是 redis 客户端与服务器之间使用得通讯协议，特点：实现简单、快速解析、可读性好  

### 架构模式

#### 主从复制（Slaveof）

Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品。  
建立连接后，主节点将内存快照分发至从节点，之后会持续把缓冲区的写命令发送给从节点。

- 降低主库读压力
- 故障恢复无法自动化
- 写操作无法负载均衡
- 存储能力受到单机限制

#### 代理（Twemproxy）

#### 哨兵（Redis Sentinel）

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中有三个特性：

监控：Sentinel 会不断检查主从服务器是否运作正常。  
提醒：Sentinel 可以通过 API 向管理员发送通知。  
故障转移：当一个主服务器故障时，Sentinel 会开始自动故障迁移操作。

#### 集群（Redis Cluster）

- 无中心架构
- 数据以 hash slot 的方式分布在多个节点上
- 实现故障自动转移，节点之间通过 gossip（流言）协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。
- 数据通过异步复制，不保证强一致性
- 所有节点彼此互联（PING-PONG机制），内部使用二进制协议优化传输速度和带宽。
- 节点的 Fail 是通过集群中超过半数的节点检测失效时才生效。
- 客户端与节点直连，不需要中间 Proxy 层，连接集群中任何一个可用几点即可。
- redis-cluster 把所有物理节点映射到 16384 slot 上，使用 CRC16（key） mod 16384 的值，决定将一个 key 放到哪个桶中。

### Redlock 算法

向 n 个节点发送 `set {lock key} {random id} px {timeout} nx` 命令，若超过半数节点执行成功，且可用时间（获取锁成功的时间 - 开始获取锁的时间） < 锁失效的时间，则加锁成功。否则，撤销锁。

通常要设置锁有效时间远大于锁使用的时间，如果没有办法避免这种情况。可以开启一个定时线程主动更新锁的 ttl，当业务代码执行完毕后关闭定时器。这里注意避免业务代码异常退出，导致的死锁情况。可以通过 final 或定时线程最大执行次数来保障。

设置随机值主要是为了防止锁被其它客户端删除。有这么一种情况：

1. A 获得了锁，还没有执行结束，但锁超时自动释放了；
2. B 此时过来，是可以获得锁的，加锁成功；
3. 此时，A 执行结束了，要去释放锁。如果不对比随机值，就会把 B 的锁给释放了；

释放锁可以通过 lua 脚本实现原子操作，判断 random id 是否相同，然后删除锁。

```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end
```

获取当前时间（start）  
一次向 N 个 Redis 节点请求锁。为了保证在某个节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间。  
计算获取锁的过程总共消耗多长时间（cunsumeTime = end - start）。如果客户端从大多数节点（>= N / 2 + 1）成功获取锁，并且获取锁的总时长没有超过锁的有效时间，则客户端认为获取成功，否则，获取失败。  
如果最终获取锁成功，锁的有限时间应该重新设置为锁的最初有效时间减去 consumeTime。  
如果最终获取锁失败，客户端应该立刻向所有节点发起释放锁的请求。

### FAQ

Q：为什么这么快？

1. 编程语言：Redis是用C语言编写的，更接近底层，可以直接调用os函数。
2. 基于内存：因为Redis的数据存储在内存中，类似于 HashMap，优势就是查找和操作的时间复杂度都是 O(1)。
3. 单线程：因为Redis是单线程的，所以避免了线程切换的消耗，也不会有竞争，所以更快。
4. 网络模型：由于Redis的网络模型是epoll，是多路复用的网络模型。
5. Redis数据结构的优化：Redis中提供了5种数据类型，其中zset用跳表做了优化，而且整个Redis其实也都用hash做了优化，使其的时间成本是O(1)，查找更快。
6. Redis6.0推出了I/O Threads，所以更快。

Q：Redis单线程是如何协调业务与垃圾回收的？

- 文件事件：redis处理客户端命令，套接字读写，键值对写入读取等
- 时间事件：redis内部垃圾回收事件，垃圾回收调用serverCron函数，需要定期执行

Redis单线程逻辑上先处理文件事件，后处理时间事件，实际执行的时间事件的时间可能略晚于时间事件所设定的时间，而且如果文件事件执行时间过长会break留到下次继续执行，把控制权交给时间事件。反之时间事件会调用子线程执行，让出控制权给文件事件。不会出现抢占等事件。

#### 其它工具

慢查询分析、性能测试、Pipeline、事务、Lua脚本、Bitmaps、发布/订阅、Geo 等功能

#### 和数据库的一致性问题

无法保证缓存和数据库之间的强一致性，只能采取合适的策略来降低缓存和数据库间的不一致概率。合适的策略包括：缓存更新策略、缓存失败时增加重试机制。

#### 海量数据的正确操作方式

由于 redis 是单线程模型，keys 命令会阻塞数据库，因此可以使用 SCAN 系列的命令完成数据迭代

#### Pipeline

一次操作中执行多个命令，减少网络消耗。
Pipeline 命令非原子性操作

## 缓冲

缓冲可以优化写入性能，合并操作。
