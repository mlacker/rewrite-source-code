# JVM

Java 的宣传口号是 Write Once, Run Anywhere

Java 虚拟机 Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM 实现了 Java 语言最重要的特征：即平台无关性。

原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

---

- JVM 的工作原理能简单说一下嘛？
  Java 程序编译为字节码后，在不同的操作系统依靠虚拟机进行解释、即使编译转换为机器码，最终得到执行。同时 JVM 提供了内存模型、类加载机制、内存分配和垃圾回收机制。
- JVM 提供了哪些的编译器？就两种是吗？
  JVM 提供了解释器，JIT 即使编译器，AOT 编译器。其中 JIT 编译器包含 C1, C2 两种编译模式。
- 内存模型分几块？
  虚拟机栈、本地方法栈、程序计数器、堆内存、元空间、运行时常量池、直接内存
- 堆和栈分别存储哪些数据？
  栈存储本地变量，对象的引用。而堆存储对象实例。
- new 一个 Integer 存储在哪里？
- 在方法内创建 Integer 变量，当方法执行完毕后会被回收吗？
  方法创建 Integer 变量，会在堆上分配内存，当方法执行完毕后栈帧被回收，对象也会在 GC 时回收。

## 内存

### 内存分布

根据 Java 虚拟机规范的规定，Java 虚拟机管理的内存包括以下几个运行时数据区域：

- 程序计数器（Program Counter Register）
- 本地方法栈（Native Method Stack）
- Java 虚拟机栈（VM Stack）
- Java 堆（Heap）
- 元空间（Metaspeace）
- 直接内存（Direct Memory）
  使用 Native 函数库直接分配的对外内存，通过 DirectByteBuffer 对象操作。

### 对象的内存布局

对象在堆内存中的存储布局分为三个部分：对象头（Header）、实例数据（Instance Data）和对象填充（Padding）。其中对象头分为 Mark Word 和指向它的类型元数据的指针。如果对象是一个数组，还有一块用于记录数组的长度。

Mark Word 包含哈希码、GC 年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。

存储内容 | 标志位 | 状态
--|--|--
hash:25, age:4, biased:1 | 01 | 未锁定(1)
thread:23, epoch:2, age:4, biased:0 | 01 | 可偏向(0)
指向锁记录的指针 | 00 | 轻量级锁定
指向重量级锁的指针 | 10 | 重量级锁
空,不需要记录信息 | 11 | GC 标记

## GC

### 垃圾收集器

#### Serial / SerialOld

单线程串行收集器，新生代采用标记-复制算法，老年代采取标记-整理算法

#### ParNew

Serial 收集器的多线程并行版本

#### Parallel Scavenge / Parallel Old

并行吞吐量优先收集器，基于标记-复制算法实现的。PS 收集器的目标则是达到一个可控制的吞吐量，主要适合在后台运算而不太需要太多交互的分析任务。在 x64 2核2G内存以上，运行在 java 8 服务器模式下的默认收集器。

PS 收集器的控制是通过最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数调节的。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。  
虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

#### CMS

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器（不可控），基于标记-清除算法实现，采用增量更新算法实现并发标记，整个过程分为四个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

CMS 收集器对处理器资源非常敏感。

由于 CMS 收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现 “Concurrent Mode Failure” 失败进而导致另一次完全 “Stop The World” 的 Full GC 的产生。

#### G1

面向局部收集的设计思路和基于 Region 的内存布局形式，从整体来看是 标记-整理算法，从局部来看是标记-复制算法。全功能的垃圾收集器，它并非纯粹的追求低延迟，目标是在延迟可控的情况下，获得尽可能高的吞吐量。在 JDK 9 成为服务器模式下的默认垃圾收集器。收集过程大致分为以下四个步骤：

1. 初始标记（Initial Marking）
  Mixed GC 一定会触发 Minor GC，复用了 Minor GC 扫描 GC Roots 的操作
2. 并发标记（Concurrent Marking）
  全局并发标记，统计 Region 数据
3. 最终标记（Final Marking）
4. 筛选回收（Live Data Counting and Evacuation）

G1 收集器的停顿预测模型是以衰减均值为理论基础来实现的，G1 收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费成本，并分析得出平均值、标准偏差、置信度等统计信息。“衰减平均值”意味着它比普通的平均值更容易受到新数据的影响。

G1 收集器是通过原始快照算法实现并发收集。如果内存回收的速度赶不上内存分配的速度，G1 收集器也要被迫冻结用户线程的执行。

G1 收集器中，分为 Minor GC 和 Mixed GC，也有特殊场景可能会发生 Full GC。等到 Eden 区满了之后，会触发 Minor GC，Minor GC 同样也是会发生 Stop The World 的。G1 会动态根据最大停顿时间调整新生代和老年代的比例。Minor GC 分为三个步骤：根扫描、更新&处理 RSet、复制对象。

优点是可以指定最大停顿时间，分 Region 的内存布局、按收益动态确定回收集。  
缺点是维护卡表的内存占用（20%以上）和额外的执行负载。除了通过写后屏障来更新维护卡表，还需要写前屏障来跟踪并发时指针变化情况。

#### Shenandoah

与 G1 相似的内存布局，初始标记、并发标记等许多阶段处理思路高度一致。支持并发的整理算法，默认不适用分代收集，改用“连接矩阵”的全局数据结构来记录跨 Region 的引用关系，降低了处理跨代指针时的记忆集维护消耗。工作阶段分为：

1. 初始标记（Initial Marking）
2. 并发标记（Concurrent Marking）
3. 最终标记（Final Marking）
4. 并发清理（Concurrent Cleanup）
5. 并发回收（Concurrent Evacuation）
  把回收集里面的存活对象先复制一份到其它未被使用的 Region 中。
6. 初始引用更新（Initial Update Reference）
7. 并发引用更新（Concurrent Update Reference）
8. 最终引用更新（Final Update Reference）
9. 并发清理（Concurrent Cleanup）

Shenandoah 是通过转发指针和读内存屏障实现并发回收的，读屏障的开销更大。

#### ZGC

ZGC 收集器是一款基于 Region 内存布局，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟未首要目标的一款垃圾收集器。收集过程分为：

1. 初始标记（Initial Mark）
2. 并发标记（Concurrent Mark）
3. 最终标记（Final Mark）
4. 并发预备重分配（Concurrent Prepare for Relocate）
5. 并发重分配（Concurrent Relocate）
  核心阶段，把重分配集中的存活对象复制到新得 Region 上，并未重分配集中的每个 Region 维护一个转发表，记录从旧对象到新对象的转向关系。如果有用户线程此时并发访问了位于重分配集种得对象，这次访问将会被预置的内存屏障所截获，然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC 将这种行为成为指针的“**自愈**”（Self-Healing）能力。
6. 并发重映射（Concurrent Remap）

染色指针可以使得一旦某个 Region 的存活对象被一走之后，这个 Region 立即就能够被释放和重用。可以大幅减少在垃圾收集过程中的内存屏障的使用数量。到目前为止 ZGC 都并未使用任何写屏障（目前不支持分代收集），只是用了读屏障。

#### 并发的可达性分析

如果用户线程与收集器并发工作时，则可能会出现两种后果：

1. 原本消亡的对象错误标记为存活（浮动垃圾）
2. 原本存活的对象错误标记为已消亡（致命）

理论证明，当且仅当以下两个条件同时满足时，会产生“对象消失“的问题：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；

因此，要解决并发扫描时对象消失的问题，只需要破坏这两个条件的任意一个即可。  
由此分别产生了两种解决方案：**增量更新**（Incremental Update）和**原始快照**（Snapshot At The Beginning，SATB）

- 增量更新要破坏的是第一个条件，当黑色对象插入新的指向对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一点新插入了指向白色对象的引用之后，它就变回灰色对象了。
- 原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为艮，重新扫描一次。

无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现的。

---

- 垃圾回收器你了解哪几种，它们有什么区别？
- 说一下 JVM 的垃圾回收算法，了解到哪种程度
  PS, G1, ZGC, Shenandoah, CMS
- 垃圾回收会怎么评估使用哪些回收器？
  交互式应用使用 G1, ZGC, CMS
  CPU 密集运算使用 PS
- 选择 G1 的原因是什么？
- G1 回收器带来什么好处呢？
- G1 的特性和优缺点？哪些场景下不合适？
  化整为零，拆分多个 region 区域，价值优先回收策略，可控的全能型垃圾回收器
  缺点有额外的开销，内存占用大，筛选回收需要 STW。
  不适用与小内存，CPU 密集型应用
- CMS 相较于 G1 在业务场景中的选用怎么考虑？
  CMS 适用于内存较小，交互型应用。停顿时间不可控，吞吐量低
  G1 适用于大内存，多种应用场景。
- G1 比较适合大内存的回收器，是什么原因呢？
  经典垃圾回收器会对整个堆进行回收，内存较大时时间过长。而 G1 采用分 region 回收的策略能有效的降低停顿时间。其次，G1 占用一定量的内存不适用于小内存的应用。
- G1 有没有对堆进行年代划分？
  G1 把连续的 Java 堆分为多个大小相等的独立区域，每一个 region 可以扮演 Eden, Survivor, 或者老年代空间。
- G1 基于 region 回收的流程是什么样的？
  G1 把堆内存划分为 2048 个大小相同的区域，通过回收集回收部分区域以达到目标的停顿时间。G1 的回收分为四个阶段：初始标记、并发标记、最终标记、筛选回收
- 筛选回收的评估是在什么时候做的？G1 的扫描阶段是全堆扫描吗？***（评估可以和扫描无关）
  筛选回收阶段负责更行 Region 的统计数据，对回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划  
  G1 扫描针对全堆扫描
- G1 的回收阶段是并发的吗？***
  G1 的筛选回收阶段因为涉及存活对象的移动，是必须暂停用户线程。
- 最终标记阶段的停顿时间和内存相关吗？
  相关，内存越大并发标记时间越长，要处理的赋值器的引用变更越多。
- 有什么情况可能会退化？
  G1 的回收速度跟不上垃圾分配速度时，会退化至 FullGC 进行回收
- 并发标记的时候哪些场景会导致引用更新？如果没有原始快照会产生哪些问题？
  引用对象赋值 null，或引用其它对象
  如果没有原始快照会造成浮动垃圾或存活对象消失
- 在 JVM 调优当中做了哪些工作？
- JVM 启动参数除了内存大小以外会考虑哪些参数？
  更换合适的垃圾收集器、并发线程数、调整内存大小、期望停顿时间和吞吐量
- 具体说一下 JVM 调优碰到什么问题，具体调了什么内容，有什么样的效果
- 内存过大导致 GC 停顿时间过长，有没有考虑过拆分成多个小内存节点？
  拆分小内存节点可以有效降低回收停顿时间，内存分配速率和 PS 回收器也是主要问题。
- 最近有没有遇到过内存溢出的问题？
  Excel 导入导出、Redis 集群连接
- 没有考虑过连接池吗？（redis 连接泄露）
  定位到问题后，通过连接池修复。
- 如果在循环中不断的创建一个对象，是否会出现停顿时间较长的情况。
  循环中创建的对象会分配在年轻代，因为没有引用而回收。但在满足停顿时间的情况下，G1 会调节年轻代大小，如果内存过大的情况下也会导致停顿时间较长。
- 怎么样检查内存泄漏的情况？
- 如何排查 OOM 的问题？用什么工具和方式？
  jstat, jmap, MAT, JVitualVM, JProfile
- 如何定位导致内存溢出的对象？
  dump 内存，通过 MAT 分析内存占用，结合代码判断
- 内存溢出后导致进程退出，通过什么手段记录日志？
  -XX:+HeapDumpOnOutOfMemoryError
- 内存溢出有很多种不光是 OOM ，你了解的有哪些？包括排查策略
  栈溢出、永久代溢出、直接内存溢出
- 生产环境因活动请求量很大，存在一个现象 CPU 持续较高负载，该如何去排查？
  先定位导致 CPU 高负载的原因，无非是应用计算或GC回收导致，通过 jstat 观察回收频率，时间和效果。
- 假如定位到相关对象，对象创建的也不频繁，操作也不频繁，CPU 负载仍然很高，你觉得可能是什么问题？（是因为锁未释放，无法回收）
  可能的原因有很多，结合代码实际，根据线索排查分析。如果是 GC 活动导致 CPU 高负载，从相关的对象排查，可能占用一直未能释放。否则通过性能刨析检查 CPU 密集计算的操作。
- 如何想要恢复故障，又能做到快速排查？
- 如果内存很大，dump 文件非常耗时，如何做到快速在线排查？
  部署新实例提供业务，下线故障实例，排查故障
- 堆外内存怎么样使用，应该注意什么？
  用 java.nio.DirectByteBuffer 对象进行堆外内存的管理和使用。注意释放

## ClassLoader

- 希望设计一个热发布的功能，该怎样实现？
  通过类加载器来实现
- Java 中双亲委派有什么用？
  防止内存中存在多份同样的字节码，把类加载请求委托给父加载器去完成
- Tomcat 中违反了双亲委派怎么理解？
  Web 应用默认的类加载顺序是（打破双亲委派规则）：
  1. 先从 JVM 的 BootStarpClassLoader 中加载；
  2. 加载 Web 应用下的 /WEB-INF/classes 中的类；
  3. 加载 Web 应用下的 /WEB-INF/lib/*.jar 中的 jar 包中的类；
  4. 加载上面定义的 Common 路径下面的类；
  5. 加载上面定义的 Shared 路径下面的类；

## Compiler
