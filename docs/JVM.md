# JVM

Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM 实现了 Java 语言最重要的特征：即平台无关性。

编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

---

- JVM 的工作原理能简单说一下嘛？
  Java 程序编译为字节码后，在不同的操作系统依靠虚拟机进行解释、即使编译转换为机器码，最终得到执行。同时 JVM 提供了内存模型、类加载机制、内存分配和垃圾回收机制。
- JVM 提供了哪些的编译器？就两种是吗？
  静态编译器 javac，把 Java 源码编译为字节码的中间表示，实现语法糖和少量的优化；
  即时编译器 JIT，包含 client 和 server 两种工作模式；
  预编译器 AOT；
- 内存模型分几块？
  虚拟机栈、本地方法栈、程序计数器、堆内存、元空间（运行时常量池）、直接内存
- 堆和栈分别存储哪些数据？
  栈存储本地变量，对象的引用。而堆存储对象实例。
- new 一个 Integer 存储在哪里？
  首先会在堆内存分配对象实例并初始化，然后把实例的地址保存到变量中，变量是存储在栈帧上的。
- 在方法内创建 Integer 变量，当方法执行完毕后会被回收吗？
  方法创建 Integer 变量，会在堆上分配内存，当方法执行完毕后栈帧被回收，对象也会在 GC 时回收。

## 内存

### 内存分布

根据 Java 虚拟机规范的规定，Java 虚拟机管理的内存包括以下几个运行时数据区域：

- 程序计数器（Program Counter Register）
- 本地方法栈（Native Method Stack）
- Java 虚拟机栈（VM Stack）
- Java 堆（Heap）
- 元空间（Metaspeace）
- 直接内存（Direct Memory）
  使用 Native 函数库直接分配的堆外内存，通过 DirectByteBuffer 对象操作。

### 对象的内存布局

对象在堆内存中的存储布局分为三个部分：对象头（Header）、实例数据（Instance Data）和对象填充（Padding）。其中对象头包含 Mark Word 和指向它的类型元数据的指针。如果对象是一个数组，还有一块用于记录数组的长度。

Mark Word 包含哈希码、GC 年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。

存储内容 | 标志位 | 状态
--|--|--
hash:25, age:4, biased:0 | 01 | 未锁定(0)
thread:23, epoch:2, age:4, biased:1 | 01 | 可偏向(1)
指向锁记录的指针 | 00 | 轻量级锁定
指向重量级锁的指针 | 10 | 重量级锁
空,不需要记录信息 | 11 | GC 标记

![markOpp](https://pic2.zhimg.com/80/v2-9e2974141f1be5d88523a1aff1eacb41_720w.jpg)

## GC

多数垃圾收集器都支持分代收集策略，堆内存被划分为新生代和老年代，新生代又分为 Eden 区和 Survivor区。
通常初始对象被分配到 Eden 区，随着 Eden 区被填满后触发 Minor GC，扫描并标记 Eden + Survivor Form 区域中存活的对象，并复制到 Survivor To 区，对象的 GC age 加 1。如果 Survivor To 空间不足以容纳，则直接担保分配到老年代。
若老年代连续剩余空间小于历次 Minor GC 平均晋升空间时，或晋升时空间不足担保分配失败，则触发 Full GC 对全堆进行回收。
除此之外，若对象的年龄达到 MaxTenuringThreshold（默认15），或对象大于 PretenureSizeThreshold 阈值，或 Survivor From 空间的对象达到动态年龄，均会晋升到老年代中。

新生代的收集算法基本都采用标记-复制算法，均会产生 STW，不过由于大多数对象朝生即灭的特性，以及只有标记和复制的开销，新生代的停顿时间基本都会很短。

分代收集策略有助于提升应用的吞吐量，新生代用于回收朝生即灭的对象，老年代用于存放长期存活的对象以减少复制和回收的频率。

### 对象分配

通常对象创建时直接分配在 Eden 区，若对象大小超过 PretenureSizeThreshold（默认0）的大对象会被直接分配到老年代。

为了保证对象的内存分配过程中的线程安全性，在线程初始化时，JVM 会在 Eden 区为每个线程分配一块 TLAB （Thread Local Allocate Buffer）空间，可以提升分配效率。TLAB 默认是 Eden 区的 1%，并且在运行时不断的调整大小，使系统达到最佳的运行状态。

### 晋升条件

1. Survivor 空间不足，回收后进入老年代
2. 对象年龄达到阈值 MaxTenuringThreshold（默认15）
3. 动态年龄，当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的 TargetSurvivorRatio（默认50），年龄大于或等于该年龄的对象就可以直接进入老年代。
4. 超大对象，当超过 PretenureSizeThreshold 字节的对象直接分配到老年代

### 触发条件

Eden 区域填满时触发 **Minor GC**。

当发生以下情况时会触发 **Full GC**：

1. Minor GC 时，判断老年代连续剩余空间小于 Minor GC 平均晋升空间大小
2. Minor GC 后，部分对象晋升到老年代时空间不足，担保分配失败
3. 老年代空间不足（直接分配到老年代）
4. 元空间空间不足
5. 调用 System.gc

若使用 CMS 收集器，当老年代空间占用达到一定比例时触发 Major GC（单独收集老年代）。

### 垃圾收集器算法

#### Serial / SerialOld

单线程串行收集器，新生代采用标记-复制算法，老年代采取标记-整理算法

SerialOld 实际上是执行 Full GC 对**全堆**进行回收，并且基于整理算法，回收后即使对象年龄未达到晋升条件时，也会整理到老年代中。

#### Parallel Scavenge / Parallel Old

基于标记-复制算法实现的并行收集器，目标是达到一个可控制的吞吐量，适用于非交互式的 CPU 密集型应用或批处理。
在 x64 2核2G内存以上，运行在 java 8 服务器模式下的默认收集器。

由于实现是最简单的并行收集器，没有产生多余的开销，因此收集效率最高，相对停顿时间较长。

老年代由 PS MarkSweep GC（串行，与 SerialOld 实现相同）/ Parallel Old（并行，UseParallelOldGC 参数启用）收集，采用标记 - 整理算法。

通过设定 -XX:GCTimeRatio, -XX:MaxGCPauseMillis 目标，JVM 会收集性能监控信息，动态调整堆大小、新生代比例以提供最合适的停顿时间或者最大的吞吐量。停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。

首先满足最大暂停时间目标. 只有满足后才能解决吞吐量目标。同样, 只有在前两个目标得到满足之后, 才会考虑占用空间目标。

1. 尽量不设置最大堆，选择合适的目标吞吐量
2. 如果可以达到吞吐量目标，但是暂停时间太长，请选择一个暂停时间目标进行折衷（以降低吞吐量为代价）
3. 如果未达到吞吐量目标，请设置尽可能大的堆（小于物理可用内存）

#### ParNew / CMS

ParNew 是 Serial 收集器的多线程并行版本，采取标记 - 复制算法，负责新生代收集。

CMS（Concurrent Mark Sweep）收集器是以最短回收停顿时间为目标的收集器（不可控），基于标记-清除算法实现，采用增量更新算法实现并发标记，整个过程分为四个步骤：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

采取标记 - 清理算法，在清理阶段可以与程序并发运行。随着时间推移会产生大量空间碎片，导致没有连续的可用空间时，退化为 SerialOld 收集器进行整理（非常慢）

并发标记采用增量更新算法，通过写后屏障，遇到新增引用时，将当前对象重新入队。

虽然是以最短停顿时间为目标的垃圾收集器，但在较大的堆内存下可能会产生并发标记阶段时间太长，赋值器产生大量引用更新，从而导致重新标记阶段的停顿时间过长（不可控）。甚至因为无法处理“浮动垃圾”（Floating Garbage），有可能出现 “Concurrent Mode Failure” 失败进而导致另一次完全 “Stop The World” 的 Full GC 的产生。

通常并发式收集器对处理器资源非常敏感，不适用于 CPU 资源有限或 CPU 密集型应用，也不适用于大内存应用。

CMS 是为数不多会单独收集老年代的收集器。

调优思路主要是避免 Concurrent Mode Failure 蜕化的 Full GC，通过降低 -XX:CMSInitiatingOccupancyFraction=92 更早的触发 MajorGC，或增加 -XX:ConcGCThreads 并发线程数提高收集速度。

在 jdk 9 时被弃用，jdk 14 时被移除。

#### G1

面向局部收集的设计思路和基于 Region 的内存布局形式，从整体来看是 标记-整理算法，从局部来看是标记-复制算法。全功能的垃圾收集器，它并非纯粹的追求低延迟，目标是在延迟可控的情况下，获得尽可能高的吞吐量。在 JDK 9 成为服务器模式下的默认垃圾收集器。收集过程大致分为以下四个步骤：

1. 初始标记（Initial Marking）
  Mixed GC 一定会触发 Minor GC，复用了 Minor GC 扫描 GC Roots 的操作
2. 全局并发标记（Global Concurrent Marking）
3. 最终标记（Final Marking）
4. 筛选回收（Live Data Counting and Evacuation）

G1 通过原始快照 SATB 实现并发标记，通过写前内存屏障，记录移除的引用，并将引用对象标记为存活对象的方式。

G1 的停顿预测模型是以衰减均值为理论基础来实现的，G1 收集器会记录每个 Region 的回收耗时、每个 Region 记忆集里的脏卡数量等各个可测量的步骤花费成本，并分析得出平均值、标准偏差、置信度等统计信息。“衰减平均值”意味着它比普通的平均值更容易受到新数据的影响。

G1 收集器是通过原始快照算法实现并发收集。如果内存回收的速度赶不上内存分配的速度，G1 收集器也要被迫冻结用户线程的执行。

G1 收集器中，分为 Minor GC 和 Mixed GC，也有特殊场景可能会发生 Full GC。等到 Eden 区满了之后，会触发 Minor GC，Minor GC 同样也是会发生 Stop The World 的。G1 会动态根据最大停顿时间调整新生代和老年代的比例。Minor GC 分为三个步骤：根扫描、更新&处理 RSet、复制对象。

##### Minor GC 和 Mixed GC

分代式G1模式下有两种选定CSet的子模式，分别对应young GC与mixed GC：

- Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。
- Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。

可以看到young gen region总是在CSet内。因此分代式G1不维护从young gen region出发的引用涉及的RSet更新。

分代式G1的正常工作流程就是在young GC与mixed GC之间视情况切换，背后定期做做全局并发标记。Initial marking默认搭在young GC上执行；当全局并发标记正在工作时，G1不会选择做mixed GC，反之如果有mixed GC正在进行中G1也不会启动initial marking。
在正常工作流程中没有full GC的概念，old gen的收集全靠mixed GC来完成。

首先要先认识清楚G1的几种收集模式：
1、young GC（或者叫minor GC）：只收集young gen里的所有region，也就是eden和survivor。控制young GC开销的手段是动态改变young region的个数；
2、mixed GC：收集young gen里的所有region，外加若干选定的old gen region。控制mixed GC开销的手段是选多少个、哪几个old gen region。
3、其实没有3了。G1 GC的控制范围内没有full GC。如果mixed GC无法跟上mutator分配的速度，导致没有足够的空region来完成mixed GC，那么就会使用serial old GC（mark-compact）来对整堆收集一次。

young 和 old regions 都是以 mixed collection 进行GC的. 为了收集 old regions, G1 会对堆中的存活对象进行完整标记. 这种标记是通过 concurrent marking 阶段完成的. 当整个 Java 堆的占用量达到参数 InitiatingHeapOccupancyPercent 的值时, 启动 concurrent marking 阶段.

-XX:G1HeapRegionSize: 1MB~32MB，默认区域数量为：Heap Size / 2^log(Initial Heap Size / 2048)

优点是可以指定最大停顿时间，分 Region 的内存布局、按收益动态确定回收集。  
缺点是维护卡表的内存占用（20%以上）和额外的执行负载。除了通过写后屏障来更新维护卡表，还需要写前屏障来跟踪并发时指针变化情况。

#### Shenandoah

与 G1 相似的内存布局，初始标记、并发标记等许多阶段处理思路高度一致。支持并发的整理算法，默认不适用分代收集，改用“连接矩阵”的全局数据结构来记录跨 Region 的引用关系，降低了处理跨代指针时的记忆集维护消耗。工作阶段分为：

1. 初始标记（Initial Marking）
2. 并发标记（Concurrent Marking）
3. 最终标记（Final Marking）
4. 并发清理（Concurrent Cleanup）
  清理没有存活对象的区域
5. 并发回收（Concurrent Evacuation）
  把回收集里面的存活对象先复制一份到其它未被使用的 Region 中
6. 初始引用更新（Initial Update Reference）
  无特殊操作，建立线程集合点
7. 并发引用更新（Concurrent Update Reference）
8. 最终引用更新（Final Update Reference）
9. 并发清理（Concurrent Cleanup）

Shenandoah 是通过转发指针和读内存屏障实现并发回收的，读屏障的开销更大。

#### ZGC

ZGC 收集器是一款基于 Region 内存布局，暂未使用分代收集策略，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟未首要目标的一款垃圾收集器。收集过程分为：

1. 初始标记（Initial Mark）
2. 并发标记（Concurrent Mark）
3. 最终标记（Final Mark）
4. 并发预备重分配（Concurrent Prepare for Relocate）
  重置 Region 的转发表
5. 并发重分配（Concurrent Relocate）
  核心阶段，把重分配集中的存活对象复制到新得 Region 上，并未重分配集中的每个 Region 维护一个转发表，记录从旧对象到新对象的转向关系。如果有用户线程此时并发访问了位于重分配集种得对象，这次访问将会被预置的内存屏障所截获，然后立即根据 Region 上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC 将这种行为成为指针的“**自愈**”（Self-Healing）能力。
6. 并发重映射（Concurrent Remap）
  合并到下一轮的并发标记阶段处理

染色指针可以使得一旦某个 Region 的存活对象被一走之后，这个 Region 立即就能够被释放和重用。可以大幅减少在垃圾收集过程中的内存屏障的使用数量。到目前为止 ZGC 都并未使用任何写屏障（目前不支持分代收集），只是用了读屏障。

适用于较大内存，对停顿时间敏感的应用。最大停顿时间不超过 10ms，以 G1 15% 吞吐量降低为目标设计的。
由于尚未使用分代收集策略，在并发过程中无法应付对象分配速率较快所产生的浮动垃圾，最终空间不足而产生 STW。
无法启用指针压缩，从系统监控上看占用内存较大。

在 jdk 11 加入，jdk 14 可用于生产。

#### 并发的可达性分析

如果用户线程与收集器并发工作时，则可能会出现两种后果：

1. 原本消亡的对象错误标记为存活（浮动垃圾）
2. 原本存活的对象错误标记为已消亡（致命）

理论证明，当且仅当以下两个条件同时满足时，会产生“对象消失“的问题：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用；

因此，要解决并发扫描时对象消失的问题，只需要破坏这两个条件的任意一个即可。  
由此分别产生了两种解决方案：**增量更新**（Incremental Update）和**原始快照**（Snapshot At The Beginning，SATB）

- 增量更新要破坏的是第一个条件，当黑色对象插入新的指向对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一点新插入了指向白色对象的引用之后，它就变回灰色对象了。
- 原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为艮，重新扫描一次。

无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现的。

### 调优策略

首先根据应用特征（对象的分配速率，生存周期，可接受的停顿时间，吞吐量等）、CPU 和内存资源选择合适的垃圾收集器算法。

其次调节堆大小、最大停顿时间、吞吐量目标（或新生代比例、晋升阈值、大对象），根据 CPU 资源设定并行线程数。

避免并发模式失效，降低比例提前触发回收，增加并发线程数量加快运行时间。
避免不必要的对象创建销毁，利用对象池，线程本地变量等对象重用技术。
避免过早晋升的情况，调整 Survivor 比例，晋升年龄，大对象阈值。
避免生命周期较短的巨型对象，这些对象会直接分配到老年代。

用更多内存较小的节点实例代替内存较大的节点实例也可以降低停顿时间。

对于花费大量时间在 TLAB 之外分配对象的应用，增大 TLAB 空间使对象分配在 TLAB 中将提升分配效率。

通过延迟初始化对象，不可变对象和标准化对象，来优化应用对内存的使用。
在内存较大的系统中启用 +XX:+UseLargePages 大页提供更好的性能。

---

- 垃圾回收器你了解哪几种，它们有什么区别？
- 说一下 JVM 的垃圾回收算法，了解到哪种程度
  PS, G1, ZGC, Shenandoah, CMS
- 垃圾回收会怎么评估使用哪些回收器？
  交互式应用使用 G1, ZGC, CMS
  CPU 密集运算使用 PS
- 选择 G1 的原因是什么？
- G1 回收器带来什么好处呢？
- G1 的特性和优缺点？哪些场景下不合适？
  化整为零，拆分多个 region 区域，价值优先回收策略，可控的全能型垃圾回收器
  缺点有额外的开销，内存占用大，筛选回收需要 STW。
  不适用与小内存，CPU 密集型应用
- CMS 相较于 G1 在业务场景中的选用怎么考虑？
  CMS 适用于内存较小，交互型应用。停顿时间不可控，吞吐量低
  G1 适用于大内存，多种应用场景。
- G1 比较适合大内存的回收器，是什么原因呢？
  经典垃圾回收器会对整个堆进行回收，内存较大时时间过长。而 G1 采用分 region 回收的策略能有效的降低停顿时间。其次，G1 占用一定量的内存不适用于小内存的应用。
- G1 有没有对堆进行年代划分？
  G1 把连续的 Java 堆分为多个大小相等的独立区域，每一个 region 可以扮演 Eden, Survivor, 或者老年代空间。
- G1 基于 region 回收的流程是什么样的？
  G1 把堆内存划分为 2048 个大小相同的区域，通过回收集回收部分区域以达到目标的停顿时间。G1 的回收分为四个阶段：初始标记、并发标记、最终标记、筛选回收
- 筛选回收的评估是在什么时候做的？G1 的扫描阶段是全堆扫描吗？***（评估可以和扫描无关）
  筛选回收阶段负责更行 Region 的统计数据，对回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划  
  G1 扫描针对全堆扫描
- G1 的回收阶段是并发的吗？***
  G1 的筛选回收阶段因为涉及存活对象的移动，是必须暂停用户线程。
- 最终标记阶段的停顿时间和内存相关吗？
  相关，内存越大并发标记时间越长，要处理的赋值器的引用变更越多。但 SATB 处理有优势
- 有什么情况可能会退化？
  G1 的回收速度跟不上垃圾分配速度时，会退化至 FullGC 进行回收
- 并发标记的时候哪些场景会导致引用更新？如果没有原始快照会产生哪些问题？
  引用对象赋值 null，或引用其它对象
  如果没有原始快照会造成存活对象消失
- 在 JVM 调优当中做了哪些工作？
- JVM 启动参数除了内存大小以外会考虑哪些参数？
  更换合适的垃圾收集器、并发线程数、调整内存大小、期望停顿时间和吞吐量
- 具体说一下 JVM 调优碰到什么问题，具体调了什么内容，有什么样的效果
- 内存过大导致 GC 停顿时间过长，有没有考虑过拆分成多个小内存节点？
  拆分小内存节点可以有效降低回收停顿时间，内存分配速率和 PS 回收器也是主要问题。
- 最近有没有遇到过内存溢出的问题？
  Excel 导入导出、Redis 集群连接
- 没有考虑过连接池吗？（redis 连接泄露）
  定位到问题后，通过连接池修复。
- 如果在循环中不断的创建一个对象，是否会出现停顿时间较长的情况。
  循环中创建的对象会分配在年轻代，因为几乎没有存活对象，标记和复制的开销非常低，所以停顿时间非常短暂。
- 怎么样检查内存泄漏的情况？
- 如何排查 OOM 的问题？用什么工具和方式？
  jstat, jmap, MAT, JVitualVM, JProfile
- 如何定位导致内存溢出的对象？
  dump 内存，通过 MAT 分析对象的内存占用，保留大小，结合代码判断
- 内存溢出后导致进程退出，通过什么手段记录日志？
  -XX:+HeapDumpOnOutOfMemoryError
- 内存溢出有很多种不光是 OOM ，你了解的有哪些？包括排查策略
  栈溢出（异常输出的栈信息，无法结束的递归）、永久代溢出（类加载器、常量池）、直接内存溢出（检查直接内存的分配，或本地内存工具）
- 生产环境因活动请求量很大，存在一个现象 CPU 持续较高负载，该如何去排查？
  先定位导致 CPU 高负载的原因，通过 ps -L 或 top -H 定位线程。
- 假如定位到相关对象，对象创建的也不频繁，操作也不频繁，CPU 负载仍然很高，你觉得可能是什么问题？（是因为锁未释放，无法回收）
  可能的原因有很多，结合代码实际，根据线索排查分析。如果是 GC 活动导致 CPU 高负载，从相关的对象排查，可能占用一直未能释放。否则通过性能刨析检查 CPU 密集计算的操作。
- 如何想要恢复故障，又能做到快速排查？
  部署新实例提供业务，下线故障实例，排查故障
- 如果内存很大，dump 文件非常耗时，如何做到快速在线排查？
  jmap 查询直方图
- 堆外内存怎么样使用，应该注意什么？
  用 java.nio.DirectByteBuffer 对象进行堆外内存的管理和使用。注意释放

## ClassLoader

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的

### 类加载时机

虚拟机规范规定了有且只有 6 种情况必须立即对类进行**初始化**：

1. 遇到 new、getstatic、putstatic、invokestatic 这4条字节码指令时。
2. 对类进行反射调用的时候。
3. 当初始化类的父类还没有进行过初始化（而接口在初始化时，并不要求父接口全部完成初始化）。
4. 虚拟机启动时，用户指定的执行的主类。
5. 当使用动态语言支持时，如果 MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，则需要先触发其初始化。
6. 接口的 default 方法

### 生命周期

![类加载的生命周期](https://upload-images.jianshu.io/upload_images/14923529-ac753500687cf9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序**开始**。

#### 加载（Loading）

1. 通过全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为这个类的方法区数据的访问入口。

#### 验证（Verification）

验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

1. 文件格式验证：如是否以魔术 0xCAFEBABE 开头，主、次版本号是否在当前虚拟机处理范围之内，常量合理性验证等。
2. 元数据验证：是否存在父类，父类的继承链是否正确，非抽象类是否实现了其父类或接口之中要求实现的所有方法、字段，方法是否与父类产生矛盾等。
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。

可以考虑使用 ```-Xverify:none``` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

#### 准备（Preparation）

为**类变量**分配内存并设置初始值（零值），这些变量所使用的的内存都将在方法区进行分配。JDK9 之后的类变量存储堆内存中。

声明为 final 的类变量则根据 ConstantValue 属性赋值

#### 解析（Resolution）

虚拟机将常量池内的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

#### 初始化（Initialization）

到初始化阶段，才真正开始执行类中定义的 Java 程序代码，此阶段是执行 ```<clinit>()``` 方法的过程。

```<clinit>()``` 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的。

```<clinit>()``` 不需要显示调用父类的初始化方法，虚拟机会保证子类的 ```<clinit>()``` 执行之前，父类的 ```<clinit>()``` 方法已经执行完毕（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）。

虚拟机会保证一个类的 ```<clinit>()``` 方法在多线程环境下被正确地加锁同步。

#### 卸载（Unloading）

---

- 希望设计一个热发布的功能，该怎样实现？
  通过类加载器来实现
- Java 中双亲委派有什么用？
  防止内存中存在多份同样的字节码，把类加载请求委托给父加载器去完成
- Tomcat 中违反了双亲委派怎么理解？
  Web 应用默认的类加载顺序是（打破双亲委派规则）：
  1. 先从 JVM 的 BootStarpClassLoader 中加载；
  2. 加载 Web 应用下的 /WEB-INF/classes 中的类；
  3. 加载 Web 应用下的 /WEB-INF/lib/*.jar 中的 jar 包中的类；
  4. 加载上面定义的 Common 路径下面的类；
  5. 加载上面定义的 Shared 路径下面的类；

## 执行引擎

### 栈帧

“栈帧”（Stack Frame）是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区域中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

#### 局部变量表

局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在编译为 Class 文件时，Code 属性的 max_locals 确定了局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot）为最小单位，一个变量槽可以存放一个32位以内的数据类型，对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。

当一个方法被调用时，Java 虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法，那局部变量表中第 0 位索引的变量槽默认是用于传递方法所属对象实例的引用。其余参数则按照参数表顺序排列，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。变量槽是可以重用的。

#### 操作数栈

操作数栈（Operand Stack）是一个后入先出栈。在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将涉及的操作数压入栈顶后调用运算指令来进行的，又譬如在调用其它方法的时候是通过操作数栈来进行方法参数的传递。

#### 动态连接

每个栈帧都包含一个指向运行期常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

#### 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法。一种是“正常调用完成”，另一种是“异常调用完成”。无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行。方法正常退出时，调用者的 PC 计数器的值就可以作为返回地址。而方法异常退出时，返回地址是要通过异常处理表来确定的。

### 方法调用

方法调用阶段唯一的任务就是确定被调用的方法的版本，Class 文件的编译过程中不包含编译的连接步奏，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

#### 解析

在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这总解析能够成立的前提是：这个方法的调用版本在运行期是不可改变的。符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法和被 final 修饰的方法，这 5 种方法调用会在类加载的时候就可以把符号引用解析为直接引用。这些方法统称为“非虚方法”（Non-Virtual Method）

解析调用一定是个静态过程，在编译期就完全确定。

#### 分派

所有依赖**静态类型**来决定方法执行版本的分派动作，都成为**静态分派**。静态分派最典型应用表现就是重载。

在运行期根据**实际类型**确定方法执行版本的分派过程称为**动态分派**。

Java 语言是一门静态多分派，动态单分派的语言。

虚拟机动态分派的实现是通过运行时在实际类型的方法元数据种搜索合适的目标方法。一种基础且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table）（与此对应，在 invokeinterface 执行时也会用到接口方法表），使用虚方法表索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的。

## Compiler

### 静态编译器

javac 把 Java 源码编译为 Class 字节码

主要解析 Java 源码，构建抽象语法树，校验正确性，处理插入时注解，少量的优化动作，语法糖的实现和生成字节码。

1. 初始化注解处理器
2. 词法分析
  将源代码的字符流转变为标记（Token）集合
3. 语法分析
  根据标记序列构造抽象语法树
4. 填充符号表
5. 注解处理器
  允许读取、修改抽象语法树的任意元素，处理过后重新执行前面的阶段
6. 标注检查
  对语法的静态信息检查（变量是否声明、类型匹配）
7. 数据流及控制流分析
  对程序上下文逻辑验证（变量初始化，每条路径是否都有返回值，异常路径）
8. 解语法糖
  泛型、类型装箱拆箱、循环遍历
9. 字节码生成
  添加构造器、StringBuilder

### JIT 编译器

HotSpot 的 C1、C2 编译器，Graal 编译器

#### 编译对象和触发条件

编译对象为方法

HotSpot 虚拟机使用基于计数器的热点探测，虚拟机会为每个方法准备了两类计数器：方法调用计数器和回边计数器，计数器阈值一旦溢出，就会提交编译请求。当编译工作完成后，方法的调用入口地址就会被改写成编译后的版本。

在默认设置下，方法/回边计数器的统计有半衰周期（Counter Half Life Time），但超过一定时间限度（GC 安全点），如果次数仍然达不到阈值，则计数器会减少一半。

方法调用计数器的阈值通过 -XX:CompileThreshold=10000 来设定。
回边计数器的阈值（默认 10700）：-XX:CompileThreshold=10000 * (-XX:OnStackReplacePercentage=140 - -XX:InterpreterProfilePercentage=33) / 100

#### 编译优化策略

- 逃逸分析
- 栈上替换
- 方法内联
  其它优化的前置
- 栈上分配
  减少栈帧的开销
- 公共子表达式消除
  `a + b + c * (a + b) => E + c * E`
- 代数化简
  `E + c * E => (c + 1) * E`
- 复写传播
- 冗余存储消除
- 无用代码消除
- 乐观多态内联
  激进优化
- 分支频率预测
- 自动装箱消除
- 锁消除
- 锁膨胀
- 空检查消除
- 类型检查消除
- 范围检查消除

#### 编译器优化标志

% OSR 编译
s 同步方法
! 异常方法
n 本地方法

### AOT 编译器

提前编译器（Ahead Of Time Compiler）：Jaotc、Graal
