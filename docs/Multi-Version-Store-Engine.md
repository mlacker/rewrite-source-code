# Multi Version Store Engine

**多版本存储引擎**（MVSE）是用以解决红猫设计版本的技术实现方案，底层基于 MySQL 数据库和消息队列中间件实现，为系统元数据的存储提供低延迟、实时存储的能力，具备良好的弹性伸缩能力，可随着业务规模增长可轻松的横向扩展系统处理能力。

存储是指用于持久化平台设计时产生的元数据，而多版本即意味着在同一时刻所有的历史版本都能存储于系统当中。

## 为什么需要它？

首先我们看一下为什么需要它，以及它能解决什么问题？

### 版本

众所周知 *红猫低代码开发平台-专业版* 是一款开发**设计**类型的平台，而设计是人的思维演变过程，存在迭代、尝试、回滚、重做、分支等现象。不同于一般的事务性业务，如产品信息管理，组织机构管理，购买商品创建订单，在数据库中只需要保存**当前状态**的数据即可，很少会有对数据历史版本查询的需求。因此对于一个设计类型的系统，**版本**是一个非常重要的概念。

### 团队协作

既然是用开发平台去**开发**项目，则通常是由多个人组成的团队共同协作去实施项目。如果不能处理团队协作的问题，则不能发挥一个开发平台的核心价值，因此团队协作功能也是低代码开发平台的核心之一。

从一个人拥有数据的所属和维护权，到多个人共同拥有数据的维护权衍生出了新的问题，我们可以把这种现象抽象成计算机从单线程执行任务，到多线程并发执行任务并且共享的一份数据，存在并发修改**数据冲突**和**数据一致性**的问题。

举个栗子，小明和小伟接到任务需要共同完成一个网站的首页，但两人分别负责首页的 UI 美化和首页的内容制作。由于开发的过程是从一个不稳定的状态趋向于稳定的成果，两人都不想在做自己的工作的同时受到对方的影响导致工作无法进展。所以两人都需要有一份自己设计数据的**版本**，它是独立的不受其它人提交所影响。当任务完成到某个阶段后，可以**合并**到一起查看效果。在这里再一次提出**版本**这个重要的概念，以及如何将两个独立的版本（设计数据）**合并**到一起的新问题。

### 应用分发

当前的商店应用分发采用的是完整克隆，保存 ID 映射的方式实现。不仅存在大量的冗余数据，也不利于更新设计。

如果能结合应用版本存储，不仅会极大的减少冗余数据，还能实现在更新时实现差异合并，解决冲突的特性。

### 工作流引擎

工作流对于国内的企业办公系统是必不可少的一个环节，由于工作流的特性，每一个发起的流程实例属于**长事务**的形态，而流程的设计也需要随着时间迭代修改，因此版本是工作流实现的基础。由此诞生一个问题，三代是基于代码生成的体系，我们不能在**运行时**[^1]动态的根据流程实例，生成且执行相应版本的流程设计。也就是说，我们在部署运行时之前，需要同时生成流程所有版本的设计代码，以及流程所依赖的页面、逻辑流、实体的代码，会在运行端产生大量重复的代码和命名冲突的问题。虽然多版本引擎并不能解决这一问题，但是能在解决方案上提供更好的支撑和实现方案，会在下文逐步解析。

[^1]: 运行时是通过设计元数据生成代码后，可独立部署的工作单元。

### 实时保存

满足禄恒（坑）的需求，希望该系统能实现实时保存的能力，即用户在浏览器中设计的数据，不论因何原因导致页面关闭，也不会丢失设计数据。对用户来说，有时候丢失一些重要的数据是令人非常懊恼的一件事情，虽然是一个很好的想法，但在当时看起来基本不可能实现。因为三代的数据结构不同于二代，二代保存数据是以单个表单、报表、流程的颗粒度进行存储，大家设计相同表单的冲突概率低（假如设计同一个表单，会存在覆盖更新的问题）。而三代是以模块为粒度进行保存，单次提交的模块设计大约在 1MB 左右，如果需要实现实时保存就需要近乎实时的频繁提交数据到服务器，不仅服务器无法承受，数据的存取延迟还很高。

### Git

## 逐步实现

### 元数据

现在思考一下该如何实现，首先我们看一下设计元数据是什么样的，我们模拟一段创建订单的业务场景，主要目的是为了表达设计元数据的片段，业务逻辑简单了解下即可。

```json
// 模块
{
    "id": 1000,
    "name": "ModuleA",
    // 实体
    "entities": [
        {
            "id": 1100,
            "name": "User",
            "properties": [
                { "id": 1101, "name": "Id", "dataType": "Integer", "required": true },
                { "id": 1102, "name": "Name", "dataType": "Text" },
                { "id": 1103, "name": "Balance", "dataType": "Decimal" }
            ]
        },
        {
            "id": 1200,
            "name": "Order",
            "properties": [
                { "id": 1201, "name": "Id", "dataType": "Integer", "required": true },
                { "id": 1202, "name": "Buyer", "dataType": "Integer" },
                { "id": 1203, "name": "Amount", "dataType": "Decimal" }
            ]
        }
    ],
    // 操作（逻辑流）
    "actions": [
        {
            "id": 1300,
            "name": "CreateOrder",
            "variables": [
                { "id": 1301, "type": "ParameterIn", "name": "User", "dataType": { "type": "EntityType", "entity": 1100 } },
                { "id": 1302, "type": "ParameterIn", "name": "Price", "dataType": "Decimal" },
                { "id": 1303, "type": "LocalVariable", "name": "Order", "dataType": { "type": "EntityType", "entity": 1200 }}
            ],
            "nodes": [
                { "id": 1304, "type": "Start" },
                { "id": 1305, "type": "Assign",
                    "assignments": [
                        "User.Balance = User.Balance - Price",
                        "Order.UserId = User.Id",
                        "Order.Amount = Price"
                    ]
                },
                { "id": 1306, "type": "RunServerAction", "name": "CreateOrder", "source": "Order" },
                { "id": 1307, "type": "End" }
            ],
            "connectors": [
                { "id": 1308, "source": 1304, "target": 1305 },
                { "id": 1309, "source": 1305, "target": 1306 },
                { "id": 1310, "source": 1306, "target": 1307 }
            ]
        }
    ],
    // 页面
    "pages": []
}
```

以上的元数据中，描述了用户、订单两个实体，和一个创建订单的逻辑流。创建订单的执行逻辑为：

1. 通过输入参数，传入购买商品的用户，商品的价格
2. 通过本地变量，创建一个空订单
3. 执行赋值，
    - 用户的余额扣减
    - 分配订单的买家为当前用户
    - 分配订单的金额为商品价格
4. 创建订单并写入数据库

这样一段的设计数据该如何存储在数据库中呢？红猫低代码平台中存在非常多不同类型的设计元素，如页面、组件、操作（逻辑流）、变量、参数、各种各样的节点、实体、实体属性、结构、资源等等，并且随着产品的研发在不断的增加，调整。我们不能像传统开发手段一样为每一种类型建立一张数据库表，来存储这些结构化数据。所以我们使用无结构化的方案来实现存储。我们来看一下它的存储结构。

```SQL
mysql> SELECT * FROM module;
+------+------------------------------------------------------------------------------+
| id   | metadata                                                                     |
+------+------------------------------------------------------------------------------+
| 1000 | { id: 1000, name: 'ModuleA', entities: [...], actions: [...], pages: [...] } |
+------+------------------------------------------------------------------------------+
1 row in set (0.04 sec)
```

### 版本存储

我们接下来继续回到版本引擎的设计，首先需要满足版本的特性，则需要将每一个版本的元数据都存储倒数据库中的一条记录，并增加版本属性。

```SQL
mysql> SELECT * FROM module;
+------+---------+--------------------------------------------------------------------------------+
| id   | version | metadata                                                                       |
+------+---------+--------------------------------------------------------------------------------+
| 1000 |       0 | { id: 1000, name: 'ModuleA', entities: [...], actions: [...], pages: [...] }   |
| 1000 |       1 | { id: 1000, name: 'ModuleA-1', entities: [...], actions: [...], pages: [...] } |
| 1000 |       2 | { id: 1000, name: 'ModuleA-2', entities: [...], actions: [...], pages: [...] } |
+------+---------+--------------------------------------------------------------------------------+
3 rows in set (0.05 sec)
```

假设一个模块的设计元数据占用 1MB 的空间，每分钟保存一个版本，每天平均工作 4小时，那么 4天就能产生 1G 的存储。随着用户量增加，系统访问量增大，不论是对磁盘IO还是网络IO都是很大的开销。我们考虑一下该如何优化？

### 差异堆叠

通过观察上面的数据，发现每次版本的变动并非所有的数据都会改变，那么我们是不是仅存储改变的内容就可以呢。看如下示例：

```SQL
mysql> SELECT * FROM module_diff;
+------+---------+------------------------------------------------------------------------------+
| id   | version | metadata                                                                     |
+------+---------+------------------------------------------------------------------------------+
| 1000 |       0 | { id: 1000, name: 'ModuleA', entities: [...], actions: [...], pages: [...] } |
| 1000 |       1 | { name: 'ModuleA-1' }                                                        |
| 1000 |       2 | { name: 'ModuleA-2', label: '模块A' }                                        |
+------+---------+------------------------------------------------------------------------------+
3 rows in set (0.04 sec)
```

通过存储差异确实有效的减少了存储空间的占用，不过如果仅仅是表示对象属性的新增或者，通过合并两个版本的数据，很容易实现，就像上方的例子。但如果是想删除一个属性，该如何表示呢？

不幸的是，标准的 JSON 格式无法表示对象属性的移除。同样，对数组的新增也很容易实现，看如下示例：

```JSON
// version 1
[
    { foo: 'a' },
    { foo: 'b' }
]
// version 2
[
    { foo: 'c' }
]
// merge 1, 2
[
    { foo: 'a' },
    { foo: 'b' },
    { foo: 'c' }
]
```

但是如何表示修改其中一个元素，移除一个元素，或调整两个元素之间的顺序呢？除非使用完整的数组数据覆盖或使用其它形式来表示增改删。前者又产生数据尺寸较大的问题，后者使用非标准格式带来兼容性的问题。现在碰到了第一个问题，我们先搁置这个问题，稍后再考虑。

> 其实这里考虑过许多方案，但多多少少都存在一些问题或引入复杂度成本较高。

### 元数据粒度

我们的元数据存储粒度应该在模块级别，页面/操作/实体级别，还是元素级别呢？我们把最初的基于模块粒度的元数据拿过来看一下

```json
// 模块
{
    id: 1000,
    name: 'ModuleA',
    // 实体
    entities: [
        {
            id: 1100,
            name: 'User',
            properties: [
                { id: 1101, name: 'Id', dataType: 'Integer', required: true },
                { id: 1102, name: 'Name', dataType: 'Text' },
                { id: 1103, name: 'Balance', dataType: 'Decimal' }
            ]
        },
        {
            id: 1200,
            name: 'Order',
            properties: [
                { id: 1201, name: 'Id', dataType: 'Integer', required: true },
                { id: 1202, name: 'Buyer', dataType: 'Integer' },
                { id: 1203, name: 'Amount', dataType: 'Decimal' }
            ]
        }
    ],
    // 操作（逻辑流）
    actions: [
        {
            id: 1300,
            name: 'CreateOrder',
            variables: [
                { id: 1301, type: 'ParameterIn', name: 'User', 
                    dataType:  { type: 'EntityType', entity: 1100 }
                },
                { id: 1302, type: 'ParameterIn', name: 'Price', dataType:  Decimal },
                { id: 1303, type: 'LocalVariable', name: 'Order', 
                    dataType:  { type: 'EntityType', entity: 1200 }
                },
            ],
            nodes: [
                { id: 1304, type: 'Start' },
                { id: 1305, type: 'Assign', 
                    assignments: [ 
                        'User.Balance = User.Balance - Price', 
                        'Order.UserId = User.Id', 
                        'Order.Amount = Price'
                    ]
                },
                { id: 1306, type: 'RunServerAction', name: 'CreateOrder', source: 'Order' },
                { id: 1307, type: 'End' }
            ],
            connectors: [
                { id: 1308, source: 1304, target: 1305 },
                { id: 1309, source: 1305, target: 1306 },
                { id: 1310, source: 1306, target: 1307 },
            ]
        }
    ],
    // 页面
    pages: [
        ...
    ]
}
```

以模块为粒度的存储，存在以下问题：

- 无法实现实时保存功能
    就像前文所说，如果需要保存用户的每一个操作，就不能以模块级别提交数据。
- 不利于 MySQL 的存储优化
    模块数据的尺寸过大，在聚集索引上要占据更多的空间，以至于产生更多的节点降低 B+Tree 的查找效率
- 限制了差异存储的选择
    如果以模块为基本粒度存储，则无法使用覆盖的方式实现数组差异存储功能
- 不利于扩展性和性能优化
    更小的粒度意味着更大的操作空间，不论是并行运算能力还是平台的扩展性，优于更大粒度的存储

在这里我们先解释下什么是元素，为了提供一致性模型，平台中的一切皆元素。元素可以是模块、页面、操作、实体、结构，也可以是操作中的变量、节点，实体结构中的属性、索引，页面中的组件等等。所以，我们现在以元素为粒度，重新整理一下数据结构

```JSON
[
    // 模块
    { id: 1000, name: 'ModuleA', entities: [1100, 1200], actions: [1300],pages: [] },
    // 实体
    { id: 1100, name: 'User', properties: [1101, 1102, 1103] },
    { id: 1200, name: 'Order', properties: [1201, 1202, 1203] },
    // 实体属性
    { id: 1101, name: 'Id', dataType: 'Integer', required: true },
    { id: 1102, name: 'Name', dataType: 'Text' },
    { id: 1103, name: 'Balance', dataType: 'Decimal' },
    { id: 1201, name: 'Id', dataType: 'Integer', required: true },
    { id: 1202, name: 'Buyer', dataType: 'Integer' },
    { id: 1203, name: 'Amount', dataType: 'Decimal' },
    // 操作
    { id: 1300, name: 'CreateOrder', variables: [1301, 1302, 1303], nodes: [1304, 1305, 1306, 1307], connectors: [1308, 1309, 1310] },
    // 操作变量
    { id: 1301, type: 'ParameterIn', name: 'User', dataType: { type: 'EntityType', entity: 1100 } },
    { id: 1302, type: 'ParameterIn', name: 'Price', dataType: Decimal },
    { id: 1303, type: 'LocalVariable', name: 'Order', dataType: { type: 'EntityType', entity: 1200 } },
    // 操作节点
    { id: 1304, type: 'Start' },
    { id: 1305, type: 'Assign', 
        assignments: [ 
            'User.Balance = User.Balance - Price', 
            'Order.UserId = User.Id', 
            'Order.Amount = Price'
        ]
    },
    { id: 1306, type: 'RunServerAction', name: 'CreateOrder', source: 'Order' },
    { id: 1307, type: 'End' },
    // 操作连接
    { id: 1308, source: 1304, target: 1305 },
    { id: 1309, source: 1305, target: 1306 },
    { id: 1310, source: 1306, target: 1307 },
]
```

值得注意的是我们不仅把粒度降到了元素级别，元素与元素之间的关系也从对象式的嵌套变为了关系式的引用，这位我们带来了一些优势：

- 解决了前文如何**表示差异**的问题
  - 因为元素对象的足够小，新版本可以存储完整内容来覆盖上一个版本。
  - 因为数组变成了关系式的引用，同样通过存储全部内容。既可以表示新增、修改、删除，也可以表示新的顺序。
- 一个对象可以被多个对象关联，而没有冗余存储的问题
- 未来在实现依赖查询的时候非常容易，只需要建立元素之间的关联信息即可
- 在元素级别的全量存储，是一种平衡的考量。既减少空间的占用（并非完全），又能减少大量的计算。

> 虽然在存储上还有进一步的优化空间，但是会带来查询的复杂度。
> 目前已经能实现版本存储、差异堆叠、实时保存的能力，所以当前的方案已经满足功能性、存储、性能、复杂性的要求。

```SQL
mysql> SELECT * FROM element;
+------+--------+-----------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------+
| id   | commit | module_id | type            | metadata                                                                                                                                  |
+------+--------+-----------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------+
| 1000 |      0 |      1000 | Module          | {"id": 1000, "name": "ModuleA", "pages": [], "actions": [1300], "entities": [1100, 1200]}                                                 |
| 1100 |      0 |      1000 | Entity          | {"id": 1100, "name": "User", "properties": [1101, 1102, 1103]}                                                                            |
| 1101 |      0 |      1000 | EntityProperty  | {"id": 1101, "name": "Id", "dataType": "Integer", "required": true}                                                                       |
| 1102 |      0 |      1000 | EntityProperty  | {"id": 1102, "name": "Name", "dataType": "Text"}                                                                                          |
| 1103 |      0 |      1000 | EntityProperty  | {"id": 1103, "name": "Balance", "dataType": "Decimal"}                                                                                    |
| 1200 |      0 |      1000 | Entity          | {"id": 1200, "name": "Order", "properties": [1201, 1202, 1203]}                                                                           |
| 1201 |      0 |      1000 | EntityProperty  | {"id": 1201, "name": "Id", "dataType": "Integer", "required": true}                                                                       |
| 1202 |      0 |      1000 | EntityProperty  | {"id": 1202, "name": "Buyer", "dataType": "Integer"}                                                                                      |
| 1203 |      0 |      1000 | EntityProperty  | {"id": 1203, "name": "Amount", "dataType": "Decimal"}                                                                                     |
| 1300 |      0 |      1000 | ServerAction    | {"id": 1300, "name": "CreateOrder", "nodes": [1304, 1305, 1306, 1307], "variables": [1301, 1302, 1303], "connectors": [1308, 1309, 1310]} |
| 1301 |      0 |      1000 | ParameterIn     | {"id": 1301, "name": "User", "type": "ParameterIn", "dataType": {"type": "EntityType", "entity": 1100}}                                   |
| 1302 |      0 |      1000 | ParameterIn     | {"id": 1302, "name": "Price", "type": "ParameterIn", "dataType": "Decimal"}                                                               |
| 1303 |      0 |      1000 | LocalVariable   | {"id": 1303, "name": "Order", "type": "LocalVariable", "dataType": {"type": "EntityType", "entity": 1200}}                                |
| 1304 |      0 |      1000 | Start           | {"id": 1304, "type": "Start"}                                                                                                             |
| 1305 |      0 |      1000 | Assign          | {"id": 1305, "type": "Assign", "assignments": ["User.Balance = User.Balance - Price", "Order.UserId = User.Id", "Order.Amount = Price"]}  |
| 1306 |      0 |      1000 | RunServerAction | {"id": 1306, "name": "CreateOrder", "type": "RunServerAction", "source": "Order"}                                                         |
| 1307 |      0 |      1000 | End             | {"id": 1307, "type": "End"}                                                                                                               |
| 1308 |      0 |      1000 | Connector       | {"id": 1308, "source": 1304, "target": 1305}                                                                                              |
| 1309 |      0 |      1000 | Connector       | {"id": 1309, "source": 1305, "target": 1306}                                                                                              |
| 1310 |      0 |      1000 | Connector       | {"id": 1310, "source": 1306, "target": 1307}                                                                                              |
+------+--------+-----------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------+
20 rows in set (0.13 sec)
```

### 分库分表

随着数据的规模集增长，大约单表达到 3000W 条记录时会产生性能瓶颈，MySQL 的查询、写入性能骤降。所以我们使用分库分表的方案来解决这一问题。

分库分表不仅能解决性能瓶颈的问题，即使在小数据规模，也能随着分库的数量，带来并发性能的成倍提升。同时也增加了平台的可靠性。

分库分表就不逐步分析直接说结论了，方案如下：

采用 sharding-jdbc 实现驱动级别的代理，对开发人员透明不会增加开发成本。
element 表拆分为 8个分区，以 module_id 作为分区键，使用 module_id % 8 作为分区策略，均匀的将数据分散在 8个分区中。
可以前期降低运维的复杂度，可以将8个分区存储在单个数据库实例中，后期可将分区分布在任意数据库实例节点中，提供水平扩展能力。
基于 module-id 分片的优势，可以不用考虑因分库分表带来的分布式事务问题，因为事务的聚合边界都在模块内部。其二，不论查询、写入均能在单个库实例中完成，降低了开发成本。其三，因为模块的基数很大，所以能把热点数据均匀的分配到多个数据库实例中，避免单个节点的热点查询。
选择8个分片，是对未来前瞻性的考虑，避免未来需要数据扩容所带来的迁移问题，前期可以随着数据增长，分别将8个分片分散到 1、2、4、8 个数据库实例中。如果数据规模进一步增长到 24亿以上，我们可以以指数倍的方式继续扩容，例如 16、32 个分片，这样能有效的减少扩容迁移数据的复杂度。

### 实时保存的实现

接下来考虑如何实现实时保存，基于版本存储引擎，在实现实时保存的特性就变得非常方便了。只需要基于 websocket 技术，由客户端建立到服务端的长连接，每当用户对任何元素的任意修改时，都只需要将该元素发送至版本引擎存储，而非整个模块的数据，因此能实时保存得以能实现。

### CQRS

用户实时保存所产生的元数据，我们可以抽象的看成日志，或者一条条事件，是一种顺序写入的流式处理，可以有效地提高存储效能。但是从查询来看，我们并不会像保存那样一条条的元素进行查询，而是返回整个模块元数据，因此可以看作查询和写入有各自不同的逻辑，这种模式与 CQRS 架构模式非常相似。

CQRS， 即命令查询的职责分离（Command Query Responsibility Segregation），我们可以将写入和查询操作，由于彼此的任务目标不同，因此独立的分为两个不同的服务。这样做的优势是彼此之间可以适用更合适的处理逻辑，提供更好的写入性能和查询性能，也因为减少了双方的耦合在代码实现上更加灵活。

![CQRS](https://images.cnblogs.com/cnblogs_com/cnblogsfans/697808/o_4.png)

其中，Read data store 可以使用 Redis/MongoDB 来实现，只需要保存当前元数据最新版本的快照即可。

### 多人协作

接下来考虑多人协作的实现，以目前我们实现了版本能力，并且每次查询到的都是最新版本的数据。可以简单的通过从第一个版本迭代到最后，重建完整的模块元数据。如果存在多个人同时设计相同的模块时，每个人都有不一样的数据状态，我们就不能简单的在一条线性的版本上重建结果了。参考下图：

![拥有多个主题分支的提交历史](https://git-scm.com/book/en/v2/images/topic-branches-1.png)

每个用户每次所产生的提交实际上是交错的，我们不能简单的从线性回放，重建结果。因此我们还需要引入分支的概念，看一下模型：

```SQL
mysql> SELECT * FROM branch;
+-------+-----------+---------+------+
| id    | module_id | user_id | head |
+-------+-----------+---------+------+
| 10001 |      1000 |   10000 |    4 |
+-------+-----------+---------+------+
1 row in set (0.00 sec)

mysql> SELECT * FROM commit;
+----+-----------+--------+-----------+---------------------+-----------+
| id | module_id | parent | committer | commit_time         | message   |
+----+-----------+--------+-----------+---------------------+-----------+
|  1 |      1000 |      0 |     10000 | 2022-02-25 10:59:42 | version 1 |
|  2 |      1000 |      1 |     10000 | 2022-02-25 10:59:54 | version 2 |
|  3 |      1000 |      2 |     10000 | 2022-02-25 14:14:37 | version 3 |
|  4 |      1000 |      3 |     10000 | 2022-02-25 14:14:43 | version 4 |
+----+-----------+--------+-----------+---------------------+-----------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM element;
+----+-----------+-----------+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| id | module_id | commit_id | element_id | metadata                                                                                                                                                                       |
+----+-----------+-----------+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  1 |      1000 |         1 |       1000 | {"id": 1000, "name": "ModuleA", "type": "Module", "pages": [], "actions": [1300], "entities": [1100, 1200]}                                                                    |
|  2 |      1000 |         1 |       1100 | {"id": 1100, "name": "User", "type": "Entity", "properties": [1101, 1102, 1103]}                                                                                               |
|  3 |      1000 |         1 |       1101 | {"id": 1101, "name": "Id", "type": "EntityProperty", "dataType": "Integer", "required": true}                                                                                  |
|  4 |      1000 |         1 |       1102 | {"id": 1102, "name": "Name", "type": "EntityProperty", "dataType": "Text"}                                                                                                     |
|  5 |      1000 |         1 |       1103 | {"id": 1103, "name": "Balance", "type": "EntityProperty", "dataType": "Decimal"}                                                                                               |
|  6 |      1000 |         1 |       1200 | {"id": 1200, "name": "Order", "type": "Entity", "properties": [1201, 1202, 1203]}                                                                                              |
|  7 |      1000 |         1 |       1201 | {"id": 1201, "name": "Id", "type": "EntityProperty", "dataType": "Integer", "required": true}                                                                                  |
|  8 |      1000 |         1 |       1202 | {"id": 1202, "name": "Buyer", "type": "EntityProperty", "dataType": "Integer"}                                                                                                 |
|  9 |      1000 |         1 |       1203 | {"id": 1203, "name": "Amount", "type": "EntityProperty", "dataType": "Decimal"}                                                                                                |
| 10 |      1000 |         1 |       1300 | {"id": 1300, "name": "CreateOrder", "type": "ServerAction", "nodes": [1304, 1305, 1306, 1307], "variables": [1301, 1302, 1303], "connectors": [1308, 1309, 1310]}              |
| 11 |      1000 |         1 |       1301 | {"id": 1301, "name": "User", "type": "ParameterIn", "dataType": {"type": "EntityType", "entity": 1100}}                                                                        |
| 12 |      1000 |         1 |       1302 | {"id": 1302, "name": "Price", "type": "ParameterIn", "dataType": "Decimal"}                                                                                                    |
| 13 |      1000 |         1 |       1303 | {"id": 1303, "name": "Order", "type": "LocalVariable", "dataType": {"type": "EntityType", "entity": 1200}}                                                                     |
| 14 |      1000 |         1 |       1304 | {"id": 1304, "type": "Start"}                                                                                                                                                  |
| 15 |      1000 |         1 |       1305 | {"id": 1305, "type": "Assign", "assignments": ["User.Balance = User.Balance - Price", "Order.UserId = User.Id", "Order.Amount = Price"]}                                       |
| 16 |      1000 |         1 |       1306 | {"id": 1306, "name": "CreateOrder", "type": "RunServerAction", "source": "Order"}                                                                                              |
| 17 |      1000 |         1 |       1307 | {"id": 1307, "type": "End"}                                                                                                                                                    |
| 18 |      1000 |         1 |       1308 | {"id": 1308, "type": "Connector", "source": 1304, "target": 1305}                                                                                                              |
| 19 |      1000 |         1 |       1309 | {"id": 1309, "type": "Connector", "source": 1305, "target": 1306}                                                                                                              |
| 20 |      1000 |         1 |       1310 | {"id": 1310, "type": "Connector", "source": 1306, "target": 1307}                                                                                                              |
| 32 |      1000 |         2 |       1000 | {"id": 1000, "name": "ModuleA-2", "type": "Module", "label": "模块", "pages": [], "actions": [1300], "entities": [1100, 1200]}                                                 |
| 33 |      1000 |         3 |       1000 | {"id": 1000, "name": "ModuleA-3", "type": "Module", "pages": [], "actions": [1300], "entities": [1100, 1200]}                                                                  |
| 34 |      1000 |         3 |       1311 | {"id": 1311, "expr": ["'Print1'"], "type": "Print"}                                                                                                                            |
| 35 |      1000 |         3 |       1312 | {"id": 1312, "expr": ["'Print2'"], "type": "Print"}                                                                                                                            |
| 36 |      1000 |         3 |       1300 | {"id": 1300, "name": "CreateOrder", "type": "ServerAction", "nodes": "[1304, 1305, 1306, 1307, 1311,1312]", "variables": [1301, 1302, 1303], "connectors": [1308, 1309, 1310]} |
| 37 |      1000 |         4 |       1300 | {"id": 1300, "name": "CreateOrder", "type": "ServerAction", "nodes": "[1304, 1305, 1306, 1307, 1311]", "variables": [1301, 1302, 1303], "connectors": [1308, 1309, 1310]}      |
| 38 |      1000 |         4 |       1312 | {}                                                                                                                                                                             |
+----+-----------+-----------+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
27 rows in set (0.00 sec)
```
